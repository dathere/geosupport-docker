#!/bin/bash

# Created by argbash-init v2.6.1
# ARG_OPTIONAL_SINGLE([tag],[t],[Tag to use when building or referencing images. Defaults to 'latest'],[latest])
# ARG_OPTIONAL_SINGLE([volume],[l],[Name of volume to use when creating or referencing volumes. Defaults to 'vol-geosupport'],[vol-geosupport])
# ARG_OPTIONAL_SINGLE([flavor],[f],[Flavor of image to operate on. Possible values are 'all','onbuild','dvc','default'. Defaults to 'all'],[all])
# ARG_OPTIONAL_BOOLEAN([print],[],[Print commands to stdout instead of running them (default: on).],[on])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Enable debug information (default: off).],[off])
# ARG_POSITIONAL_SINGLE([geosupport-release],[Geosupport release. E.g., 18a],[])
# ARG_POSITIONAL_SINGLE([geosupport-version],[Geosupport version. E.g., 18.1],[])
# ARG_DEFAULTS_POS()
# ARG_HELP([Minimal script for reviewing and executing image, volume and container commands for geoclient-docker])
# ARG_VERSION([echo $0 v1.0.0-SNAPSHOT])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='tlfhv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_geosupport_release=
_arg_geosupport_version=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_tag="latest"
_arg_volume="vol-geosupport"
_arg_flavor="all"
_arg_print="on"
_arg_debug="off"

print_help ()
{
  printf '%s\n' "Minimal script for reviewing and executing image, volume and container commands for geoclient-docker"
  printf 'Usage: %s [-t|--tag <arg>] [-l|--volume <arg>] [-f|--flavor <arg>] [--(no-)print] [--(no-)debug] [-h|--help] [-v|--version] <geosupport-release> <geosupport-version>\n' "$0"
  printf '\t%s\n' "<geosupport-release>: Geosupport release. E.g., 18a"
  printf '\t%s\n' "<geosupport-version>: Geosupport version. E.g., 18.1"
  printf '\t%s\n' "-t,--tag: Tag to use when building or referencing images. Defaults to 'latest' (default: 'latest')"
  printf '\t%s\n' "-l,--volume: Name of volume to use when creating or referencing volumes. Defaults to 'vol-geosupport' (default: 'vol-geosupport')"
  printf '\t%s\n' "-f,--flavor: Flavor of image to operate on. Possible values are 'all','onbuild','dvc','default'. Defaults to 'all' (default: 'all')"
  printf '\t%s\n' "--print,--no-print: Print commands to stdout instead of running them (default: on). (on by default)"
  printf '\t%s\n' "--debug,--no-debug: Enable debug information (default: off). (off by default)"
  printf '\t%s\n' "-h,--help: Prints help"
  printf '\t%s\n' "-v,--version: Prints version"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -t|--tag)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_tag="$2"
        shift
        ;;
      --tag=*)
        _arg_tag="${_key##--tag=}"
        ;;
      -t*)
        _arg_tag="${_key##-t}"
        ;;
      -l|--volume)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_volume="$2"
        shift
        ;;
      --volume=*)
        _arg_volume="${_key##--volume=}"
        ;;
      -l*)
        _arg_volume="${_key##-l}"
        ;;
      -f|--flavor)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_flavor="$2"
        shift
        ;;
      --flavor=*)
        _arg_flavor="${_key##--flavor=}"
        ;;
      -f*)
        _arg_flavor="${_key##-f}"
        ;;
      --no-print|--print)
        _arg_print="on"
        test "${1:0:5}" = "--no-" && _arg_print="off"
        ;;
      --no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo $0 v1.0.0-SNAPSHOT
        exit 0
        ;;
      -v*)
        echo $0 v1.0.0-SNAPSHOT
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'geosupport-release' and 'geosupport-version'"
  test ${#_positionals[@]} -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_geosupport_release' '_arg_geosupport_version' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


if [[ $_arg_debug == on ]]; then
  printf '%s: %s\n' 'geosupport-release' "$_arg_geosupport_release"
  printf '%s: %s\n' 'geosupport-version' "$_arg_geosupport_version"
  printf '%18s: %s\n' 'tag' "$_arg_tag"
  printf '%18s: %s\n' 'volume' "$_arg_volume"
  printf '%18s: %s\n' 'flavor' "$_arg_flavor"
  printf '%18s: %s\n' 'print' "$_arg_print"
  printf '%18s: %s\n' 'debug' "$_arg_debug"
fi

# ] <-- needed because of Argbash

GEOSUPPORT_RELEASE="$_arg_geosupport_release"
GEOSUPPORT_VERSION="$_arg_geosupport_version"

if [[ $_arg_flavor == all || $_arg_flavor == onbuild ]]; then
  printf '\n%s\n' "Building geosupport-docker:${_arg_tag}-onbuild"
  echo docker build -t mlipper/geosupport-docker:${_arg_tag}-onbuild \
               -f Dockerfile.onbuild .
fi

if [[ $_arg_flavor == all || $_arg_flavor == default ]]; then
  printf '\n%s\n' "Building geosupport-docker:${_arg_tag}"
  echo docker build --build-arg VERSION=${_arg_tag} \
               -t mlipper/geosupport-docker:${_arg_tag} \
               -f Dockerfile .
fi

if [[ $_arg_flavor == all || $_arg_flavor == dvc ]]; then
printf '\n%s\n' "Building geosupport-docker:${_arg_tag}-dvc"
echo docker build --build-arg VERSION=${_arg_tag} \
             -t mlipper/geosupport-docker:${_arg_tag}-dvc \
             -f Dockerfile.dvc .
fi

printf '\n%s\n' "Creating volume ${_arg_volume}"
echo docker volume create --name ${_arg_volume}

if [[ $_arg_flavor == all || $_arg_flavor == dvc ]]; then
  printf '\n\n'
  echo docker run -d --name geosupport-${_arg_tag}-dvc \
                --volume ${_arg_volume}:/opt/geosupport \
                -e GEOSUPPORT_RELEASE=${_arg_geosupport_release} \
                -e GEOSUPPORT_VERSION=${_arg_geosupport_version} \
                mlipper/geosupport-docker:${_arg_tag}-dvc
fi
printf '\n\nBuild complete.\n\n'
